% function decompte = compterCarres(image)
% end

% input : image
% M x N sized logical where M: height, N: width
% output : decompte
% Matrix of 1x20 of double/uint32 where n element = # of size squares
image = imread('carres.png');

%       INFORMATION
% recommended : hit or miss approach with erosion/dilations
%       FUNCTIONS
% 1) Hit or Miss :    C = bwhitmiss(A, B1, B2)
% 2) Erosion :        C = imopen(A, B)
% 3) Dilation :       C = imclose(A, B)
%       RESOURCES
% https://www.mathworks.com/help/images/ref/bwhitmiss.html


% ============== start ======================

% store received image
recImage = image;
% generate a 1x20 table to store final results
tableResults = zeros(1,20, 'uint32');

% converts image to a matrix w/ labelled connected components
% and the number of total shapes
[imageMat, numberFormesA] = bwlabel(recImage);

shapeSize = 9;

erode1_ES = strel('square', shapeSize);
erode1 = imerode(recImage, erode1_ES);

% we want to detect single pixels
hit = [0 0 0; 
        0 1 0; 
        0 0 0]

miss=~hit
Ares=bwhitmiss(erode1,hit,miss);

dilate1_ES = strel('square', shapeSize);
dilate1 = imdilate(erode1, dilate1_ES);

stateToRemove = dilate1;
subtractedState = and(recImage, ~stateToRemove);


% saves results for output of function
decompte = tableResults;

% ----------------------------- DEBUG
% because the background is black, invert it when imshow

% count the squares after erode/dilate
[imageMat2, numberFormesA2] = bwlabel(stateToRemove);
% count after subtraction
[imageMat3, numberFormesA3] = bwlabel(subtractedState);

% subplots/display
subplot(2,3,1)
imshow(~recImage)
title('Original');

subplot(2,3,2)
imshow(~erode1)
title('Erode1');

subplot(2,3,3)
imshow(~dilate1)
title('Dilate1');

subplot(2,3,4)
imshow(~subtractedState)
title('subtractedState');

subplot(2,3,5)
imshow(Ares)
title('Ares');

subplot(2,3,6)
imshow('Fraises.jpg')
title('Dilate1');


